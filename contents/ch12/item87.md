# 아이템 87. 커스텀 직렬화 형태를 고려하라

만약, 클래스가 Serializable을 구현하고 기본 직렬화 형태를 사용한다면 다음 릴리스 때 버리려 한 현재의 구현에 영원히 발이 묶이게 된다.(BigInteger와 같은 일부 자바 클래스)  
**먼저 고민해보고 괜찮다고 판단될 때만 기본 직렬화를 사용하자**

- 직렬화의 형태는 유연성, 성능, 정확성 측면에서 신중히 고민한 후 합당할 때만 사용해야 한다. 
- 기본 직렬화 형태와 거의 같은 결과가 나올 경우에만 기본 형태를 써야 한다(?)

### 기본 직렬화 형태
- 기본 직렬와 형태는 그 객체를 뤁로 하는 객체 그래프의 물리적 모습을 나름 효율적으로 인코딩한다.
- 객체가 포함한 데이터들과  그 객체에서부터 시작해 접근할 수 있는 모든 객체를 담아낸다.
- 객체들이 연결된 위상(topology)까지 기술한다.
**아쉽게도 이상적인 직렬화 형태라면 물리적인 모습과 독립된 논리적인 모습만을 표현해야 한다.**
- 객체의 물리적 표현과 논리적 내용이 같아면 기본 직렬화 형태라도 무방하다.   
    - 예제 Name
    1. 성명은 논리적으로 이름, 성, 중간이름이라는 3개의 문자열로 구성된다.
    2. Name 클래스의 인스턴스 필드들은 이 논리적 구성요소를 정확히 반영했다.
- 기본 직렬화 형태가 적합하다고 결정했더라고 불변식 보장과 보안을 위해 readObject 메서드를 제공해야 할때가 많다.
    - 예제 Name
    1. readObject 메서드가 lastName과 firstName 필드가 null이 아님을 보장해야 함
- Name의 필드들은 모두 private 임에도 불구하고 문서화 주석이 달려 있다. 이를 통해 해당 필드들은 클래스의 직렬화 형태에 포함되는 공개 API라는 것을 알 수 있다.  
**private 필드의 설명을 API 문서에 포함하라고 자바독에 알려주는 역할은 @serial 이다**
- 기본 직렬화를 사용하면 transient 필드들은 역직렬화 될 때 기본값으로 초기화된다
    > 객체 참조 필드는 null    
      숫자 기본 타입 필드는 0    
      boolean 필드는 false  

따라서 기본값을 사용하면 안되는 경우, readObject의 defaultReadObject를 호출한 다음, 해당 필드를 원하는 값으로 복원하거나, 그 값을 처음 사용할 때 초기화 하자.

### 기본 직렬화에 적합하지 않은 클래스
- 논리적인 관점 : 이 클래스는 일련의 문자열을 표현한다.
- 물리적인 관점 : 이 클래스는 문자열들을 이중 연결 리스트로 연결했다.
- 물리적 표현과 논리적 내용이 다르다는 것을 알 수 있다.   
만약 이 클래스에 기본 직렬화 형태를 사용한다면 각 노드의 양방향 연결 정보를 포함해 모든 엔트리를 기록한다

### 물리적 표현과 논리적 표현이 다른 경우, 기본 직렬화 형태를 사용하면 생기는 문제점들
1. 공개 API가 현재의 내부 표현 방식에 영구히 묶인다.
    - 더이상 사용하지 않는 부분이 생기더라도 관련 코드를 절대 제거할 수 없다.
2. 너무 많은 공간을 차지할 수 있다. 
    - 내부 구현에 해당하는 부분은 직렬화 형태에 포함할 가치가 없다. 직렬화 형태가 커지게 되면 디스크에 저장하거나 네트워크로 전송하는 속도가 늦어진다.
3. 시간이 너무 많이 걸릴 수 있다. 
    - 직렬화 로직은 객체 그래프의 위상에 관한 정보가 없으니 그래프를 직접 순회해볼 수밖에 없다.
4. 스택 오버플로우를 일으킬 수 있다. 
    - 기본 직렬화 과정은 객체 그래프를 재귀 순회하는데, 이는 스택 오버플로우를 일으킬 수 있다. 
    - StringList의 원소를 1,000 ~ 1,800개 정도 담으면 직렬화 과정에서 StackOverflowError가 발생한다.
    
### StringList에 합리적인 직렬화 형태
- 단순히 리스트가 포함한 문자열의 개수를 적은 다음, 그 뒤로 문자열들을 나열하는 수준
- StringList의 물리적인 상세 표현은 배제한 채 논리적인 구성만 담는 것
- writeObject와 readObject가 직렬화 형태를 처리하며 transient란, 일시적이란 뜻으로 해당 인스턴스 필드가 기본 직렬화 형태에 포함되지 않느다는 표시
- 성능 :   
기본 직렬화 형태에 비해 약 2배 정도 빠르게 수행되며 스택오버플로우가 발생하지 않는다.
- StringList는 기본 직렬화에 형태에 적합하지 않다.  
StringList의 기본 직렬화 형태가 유연성과 성능이 떨어졌더라도, 객체를 직렬화한 후 역지렬화하면서 원래 객체를 그 불변식까지 포함해 복원해낸다는 점에서 정확하다고 할 수 있다.  
**하지만, 세부 구현에 따라 달라지는 객체에서는 이 정확성이 깨질 수 있다**

### defaultWriteObject, defaultReadObject
- StringList의 모든 필드가 transient여도 defaultWriteObject, defaultReadObject를 호출한다.
- defaultWriteObject 메서드를 호출하면 transient가 아닌 모든 인스턴스 필드가 직렬화되므로, transient로 선언 가능한 필드에는 transient 한정자를 추가하자
**해당 객체의 논리적 상태와 무관한 필드라고 확신할때만 transient 한정자를 생략**
- 이유 :   
향후 릴리스에서 transient가 아닌 인스턴스 필드가 추가되더라도 상호 호환되기 때문  
(만약, 신버전 인스턴스를 직렬화한 후 구버전으로 역직렬화하면 새로 추가된 필드들은 무시될 것, 따라서 readObject 메서드에서 defaultReadObject를 호출하지 않는다면 역직렬화시 StreamCorruptException이 발생할 것)

### 동기화 메커니즘을 직렬화에 적용
- 객체의 전체 상태를 읽는 메서드에 적용해야 하는 동기화 메커니즘을 직렬화에도 적용해야 한다.

```java
    public synchronized  void writeObject(ObjectOutputStream s) throws IOException {
        s.defaultWriteObject();
    }
 ```
 - writeObject 메서드 안에서 동기화하고 싶다면 클래스의 다른 부분에서 사용하는 락 순서를 똑같이 따라야 한다.이를 어길시 교데드락에 빠질 수 있다.
 
 
 ### UID
 - 어떤 직렬화 형태를 택하든 직렬화 가능한 클래스 모두에 직렬 버전 UID를 명시적으로 부여하자.
 - 만약 명시하지 않으면, 런타임에 해당 값 생성을 위해 복잡한 연산을 수행하느라 성능이 조금 느려진다.
 ```java
    private static final long serialVersionUID = <무작위로 고른 long값>;
  ```
- 직렬 버전 UID가 꼭 고유할 필요는 없으며, 클래스 일련 번호를 생성해주는 serialVer 유틸리티를 사용하거나, 아무 값을 선택해도 된다.
- 직렬 버전 UID가 없는 기존 클래스를 구버전으로 직렬화된 인스턴스와 호환성을 유지한 채 수정하려면, 구버전에서 사용한 자동 생성된 값을 그대로 사용한다.
(직렬화된 인스턴스가 존재하는 구버전 클래스를 serialVer 유틸리티에 입력으로 주어 실행하면 얻을 수 있다)
- 기존 버전 클래스와의 호환성을 끊고 싶다면 직렬 버전 UID 값을 변경하면 된다. 
    - InvalidClassException 발생 
    - 하지만, 구버전으로 직렬화된 인스턴스들과의 호환성을 끊으려는 경우를 제외하고는 직렬 버전 UID를 절대 수정하지 말아야 한다. 
 
 