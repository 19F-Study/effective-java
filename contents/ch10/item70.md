# item70. 복구할 수 있는 상황에는 검사 예외를, 프로그래밍 오류에는 런타임 예외를 사용하라.

## 자바의 예외 클래스 종류 (Throwable)
* 검사예외 : Exception의 하위 클래스로 RuntimeException을 제외한 예외
* 런타임 예외 : Exception 의 하위 클래스로 RuntimeException 을 상속한 예외
* 에러 : Error의 하위 클래스로 시스템에서 발생한 심각한 오류 발생 시 사용. (프로그램에서 처리 불가)

## 예외 처리 방법
1. 예외복구 (예 - 재시도를 통한 예외 복구)
2. 예외 처리 회피 : 호출한 쪽으로 throws
3. 예외 전환 : 예외를 잡아서 다른 예외를 던짐.  
3-1. 호출한 쪽에서 예외를 받아서 처리할 때 좀 더 명확하게 인지할 수 있는 예외를 던진다. (예- SQLException을 잡아서 DuplicateUserIdException을 던짐.)
3-2. 검사 예외 중 복구 불가능한 예외가 잡혔다면 이를 비검사 예외로 전환하여서 다른 계층에서 예외를 처리를 강제하지 않도록 함.

## 검사 예외 (checked exception)
* 호출하는 쪾에서 복구하리라 여겨지는 상황이라면 검사 예외를 사용.  
* 검사 예외를 던지면 호출자가 그 예외를 catch로 잡아 처리하거나 더 바깥으로 전파하도록 강제하게 됨.  
* 메서드 선언에 포함된 검사 예외는 그 메서드를 호출했을 때 발생할 수 있는 유력한 결과임을 API 사용자에게 알려줌.  
* 검사예외는 API 사용자에게 그 상황을 회복하라고 요구하는 것으로 예외를 잡고 아무 조치를 취하지 않는 것은 좋지 않다.  

## 비검사 예외 (unchecked exception)
* 런타임예외와 에러 두가지가 있다.  
* 프로그램에서 잡을 필요가 없거나 혹은 통상적으로 잡지 말아야 한다.
* 프로그램에서 비검사 예외를 던졋다는 것은 복구가 불가능하거나 더 실행해봐야 실이 많다는 뜻이다.  
* 이런 throwable을 잡지 않은 스레드는 적절한 오류 메시지를 내뱉으며 중단된다.
* 프로그래밍 오류를 나타낼 때는 런타임 예외를 사용하자.
* 런타임 예외의 대부분은 전제조건을 만족하지 못했을 때 발생한다. (예- ArrayIndexOutOfBoundException)
* 복구가 가능한지 불가능한지 확신하기 어렵다면 비검사 예외를 선택하는 편이 낫다. 
* 에러는 보통 JVM의 자원부족, 불변식 깨짐 등 더 이상 수행을 계속할 수 없는 상황을 나타낼 때 사용한다.

## 예외의 메서드  
* 예외 역시 어떤 메서드라도 정의할 수 있는 완벽한 객체이다.  
* 예외의 메서드는 그 예외를 일으킨 상황에 관해 정보를 코드 형태로 전달하는 데 쓰인다.  
* 오류 메시지를 파싱해 정보를 빼내는 것은 좋지 않다. 깨지기 쉽고 다른 환경에서 동작하지 않을 수 있으므로 적절한 예외 메서드를 제공하라.  
* 검사 예외는 일반적으로 복구할 수 있는 조건에서 발생하므로, 호출자가 예외 상황에서 벗어나는데 필요한 정보를 알려주는 메서들르 함께 제공하라. 
(예- 쇼핑몰에서 카드 잔고 부족으로 검사 예외가 발생했다면, 잔고가 얼마나 부족한지 알려주는 접근자 메서드를 제공해야 한다.)  

## 요약
* 복구할 수 있는 상황이면 검사 예외를, 프로그래밍 오류라면 비검사 예외를 던지자. 확실하지 않다면 비검사 예외를 사용하라.  
* 검사 예외도 아니고 런타임 예외도 아닌 throwable은 정의 하지도 말자.  
* 검사 예외라면 복구에 필요한 정보를 알려주는 메서드도 제공하자.

> 참고  
[clean code - 오류 처리](https://github.com/19F-Study/clean-code-study/blob/master/7%EC%9E%A5_%EC%98%A4%EB%A5%98_%EC%B2%98%EB%A6%AC/chapter7.md)