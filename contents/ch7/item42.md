# 자바8에 추가된 기능
함수 객체를 더 쉽게 만들 수 있게 하는 기능
* 함수형 인터페이스
* 람다
* 메서드 참조  

데이터 원소의 시퀀스 처리를 라이브러리 차원에서 지원하는 방법
* 스트림

 
# item42. 익명클래스 보다는 람다를 사용 하라.
* 추상 메서드를 하나만 담은 인터페이스 (드물게는 추상클래스)  
  - 함수 타입을 표현할 때 사용하며, 이런 인터페이스의 인스턴스를 함수 객체(function object)라고 함.  
  - 특정함수나 동작을 나타내기 위해 사용됨.  
  - 함수 객체를 만드는 주요 수단은 익명 클래스이다.
  
```java
// 정렬을 위한 비교함수로 익명 클래스를 사용한 예
Collections.sort(words, new Comparator<String>() {
	public int compare(String s1, String s2) {
		return Integer.compare(s1.length(), s2.length());
	}
});
```
* 익명 클래스 방식의 단점  
 : 코드가 길기 때문에 함수형 프로그래밍에 적합하지 않음.
 
* 함수형 인터페이스란 ?  
추상메서드 하나짜리 인터페이스이며, 람다식을 사용해 인스턴스를 만들 수 있다.
```java
// 람다식을 함수 객체로 사용 - 익명클래스 대체
Collections.sort(words, (s1, s2) -> Integer.compare(s1.length(), s2.length()));
```
* 타입 정보가 코드에 나타나지 않음
  * 람다 : Comparator<String>
  * 매개변수 : String
  * 반환값 : int  
-> 컴파일러가 문맥을 살펴서 타입을 추론해주기 때문.  
컴파일러가 타입을 추론할 수 없을 때에는 직접 명시해야한다.  

* 타입을 명시해야 코드가 더 명확할 때만 제외하고, 람다의 모든 매개변수 타입은 생략  
* 컴파일러가 타입을 추론하는 데 필요한 타입정보를 대부분 제네릭에서 얻는다.

```java
// 비교자 생성 메서드를 사용
Collections.sort(words, comparingInt(Sting::length));

// 자바8 List 인터페이스에 추가된 sort 메서드 이용
words.sort(comparingInt(String::length));
```

  * 람다를 언어 차원에서 지원하면서, 기존에는 적합하지 않았던 곳에서도 함수 객체를 실용적으로 사용할 수 있게 됨.
  
## 람다  
* 이름이 없고, 문서화를 못한다.  
* 코드 자체로 동작이 명확히 설명되지 않고나, 코드 줄 수가 많아지면 람다를 쓰지 말아야 한다.  
* 람다는 한줄 일 때 가장 좋고 최대 세줄이면 좋다.  
* 함수형 인터페이스에서만 사용된다. 
* 익명 클래스처럼 직렬화 형태가 구현별로(가상 머신별로) 다를 수 있으므로 람다를 직력화하는 일은 극히 삼가야 한다.  

## 람다 vs 익명클래스
1. 추상클래스의 인스턴스를 만들 때 람다를 쓸 수 없다.  
2. 추상 메서드가 여러 개인 인터페이스의 인스턴스를 만들 때 람다를 쓸 수 없다.  
3. 람다는 자신을 참조할 수 없다. 함수 객체가 자신을 참조해야 한다면 익명클래스를 사용해야한다.  
-> 람다에서의 this 키워드는 바깥 인스턴스를 가리킨다.  
 익명클래스에서의 this는 인스턴스 자신을 가리킨다.
 